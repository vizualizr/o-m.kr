-
    name: '[QuickInsertV2]'
    text: "<p>\n  <a href=\"${link}\">\n    ${linkText}\n  </a>\n</p>"
-
    name: '[QuickBackLinkV2]'
    text: "<p>\n  Referred in\n  <a href=\"${link}\">\n    ${linkText}\n  </a>\n</p>"
-
    name: '[QuickImportV2]'
    text: "<blockquote>\n${{\n  return await Zotero.BetterNotes.api.convert.link2html(link, {noteItem, dryRun: _env.dryRun});\n}}$\n</blockquote>"
-
    name: '[QuickNoteV5]'
    text: "${{\n  let res = \"\";\n  if (annotationItem.annotationComment) {\n    res += await Zotero.BetterNotes.api.convert.md2html(\n      annotationItem.annotationComment\n    );\n  }\n  res += await Zotero.BetterNotes.api.convert.annotations2html([annotationItem], {noteItem, ignoreComment: true});\n  return res;\n}}$"
-
    name: '[ExportMDFileNameV2]'
    text: "${{\r\n\tconst noteTitle = (noteItem.getNoteTitle ? noteItem.getNoteTitle().replace(/[/\\\\?%*:|\"<> ]/g, \"-\") : \"\");\r\n\tconst noteKey = noteItem.key;\r\n\tconst fileExtension = [\"mdx\", \"md\"];\r\n\tlet fileName = \"\";\r\n\r\n\tconst targetTags = [\"o-m.kr\"];\r\n\tconst noteTags = noteItem.getTags().map((_t) => _t.tag);\r\n\t\r\n\tif (targetTags.some(item => noteTags.includes(item))) {\r\n\t\tfileName = `${noteTitle} ${noteKey}.${fileExtension[0]}`;\r\n\t} else {\r\n\t\tfileName = `${noteTitle} ${noteKey}.${fileExtension[1]}`;\r\n\t}\r\n\treturn fileName.trim();\r\n}}$"
-
    name: '[ExportMDFileHeaderV2]'
    text: "${{\n\tconst targetTags = [\"o-m.kr\"];\n\n\tlet noteContent = noteItem.getNote(); // This retrieves the HTML content of the note as a string\n\n\t// Create a DOMParser to parse the HTML string\n\tlet parser = new DOMParser();\n\tconst doc = parser.parseFromString(noteContent, 'text/html');\n\n\t// Find the first blockquote element\n\tlet firstBlockquote = doc.querySelector('blockquote');\n\tlet rubric = \"\";\n\n\tif (firstBlockquote) {\n\t\tlet blockquoteText = firstBlockquote.textContent.trim();\n\t\trubric = blockquoteText;\n\t} else {\n\t\t// Zotero.debug(\"No blockquote found in the note.\");\n\t\trubric = false;\n\t}\n\n\tlet firstPre = doc.querySelector('pre');\n\tlet slug = \"\";\n\tif (firstPre) {\n\t\tlet slugText = firstPre.textContent.trim();\n\t\tslug = slugText;\n\t} else {\n\t\tslug = false;\n\t}\n\n\tlet summary;\n     // Extract images from the note\n \n    // Extract images from the note\n    const extractImages = (document) => {\n        const images = [];\n        const imgElements = document.querySelectorAll('img');\n\t\tconst syncPath = Zotero.BetterNotes.api.sync.getSyncStatus(noteItem.id).path.replace(/\\\\/g, \"/\").split(\"/src\")[1].replace(/^\\//, \"/src/\");\n        \n        imgElements.forEach((img, index) => {\n            // Handle Zotero-specific image structure\n            const attachmentKey = img.getAttribute('data-attachment-key');\n\t\t\tconst src = img.getAttribute('src') || img.getAttribute('data-src') || \"\";\n\t\t\tconst alt = img.getAttribute('alt') || `이미지 ${index + 1}`;\n            const width = img.getAttribute('width') || \"\";\n            const height = img.getAttribute('height') || \"\";\n            \n            // Try to get caption from various possible sources\n            let caption = \"\";\n            \n            // Check if image is wrapped in a figure with figcaption\n            const parentFigure = img.closest('figure');\n            if (parentFigure) {\n                const figcaption = parentFigure.querySelector('figcaption');\n                if (figcaption) {\n                    caption = figcaption.textContent.trim();\n                }\n            }\n            \n            // If no figcaption, check for title attribute\n            if (!caption) {\n                caption = img.getAttribute('title') || \"\";\n            }\n            \n            // If still no caption, check for text in parent element (like p tag)\n            if (!caption) {\n                const parent = img.parentElement;\n                if (parent && parent.tagName.toLowerCase() === 'p') {\n                    // Get text content excluding the image itself\n                    const parentClone = parent.cloneNode(true);\n                    const imgInClone = parentClone.querySelector('img');\n                    if (imgInClone) {\n                        imgInClone.remove();\n                    }\n                    const textContent = parentClone.textContent.replace(/\\s+/g, ' ').trim();\n                    // If parent has meaningful text content, use as caption\n                    if (textContent && textContent.length > 0 && textContent.length < 500) {\n                        caption = textContent;\n                    }\n                }\n            }\n            \n            // If still no caption, check following sibling elements for potential captions\n            if (!caption) {\n                let nextSibling = img.parentElement ? img.parentElement.nextElementSibling : null;\n                while (nextSibling && ['p', 'div', 'em', 'i', 'small', 'span'].includes(nextSibling.tagName.toLowerCase())) {\n                    const siblingText = nextSibling.textContent.trim();\n                    if (siblingText && siblingText.length > 0 && siblingText.length < 300) {\n                        caption = siblingText;\n                        break;\n                    }\n                    nextSibling = nextSibling.nextElementSibling;\n                }\n            }\n            \n            // Default caption if none found\n            if (!caption) {\n                caption = `이미지 ${index + 1}`;\n            }\n            \n            // For Zotero notes, we need to handle both cases:\n            // 1. Images with src attribute (external images)\n            // 2. Images with data-attachment-key (Zotero attachments)\n            let finalSrc = \"\";\n            let fileExtension = \"\";\n            \n            if (src) {\n                finalSrc = src;\n            } else if (attachmentKey) {\n                // Try to get the actual attachment item and its file extension\n                try {\n                    const attachment = Zotero.Items.getByLibraryAndKey(noteItem.libraryID, attachmentKey);\n                    if (attachment && attachment.isAttachment()) {\n                        const filename = attachment.getFilename();\n                        if (filename) {\n                            // Extract extension from filename\n                            const extensionMatch = filename.match(/\\.([^.]+)$/);\n                            if (extensionMatch) {\n                                fileExtension = extensionMatch[1].toLowerCase();\n                            }\n                            // Use the attachment key with extension for the src\n                            finalSrc = `attachments/${attachmentKey}.${fileExtension}`;\n                        } else {\n                            // Fallback: try to get file extension from attachment path\n                            const filePath = attachment.getFilePath();\n                            if (filePath) {\n                                const pathExtensionMatch = filePath.match(/\\.([^.]+)$/);\n                                if (pathExtensionMatch) {\n                                    fileExtension = pathExtensionMatch[1].toLowerCase();\n                                    finalSrc = `attachments/${attachmentKey}.${fileExtension}`;\n                                }\n                            }\n                        }\n                    }\n                } catch (error) {\n                    // If we can't access the attachment, use heuristics\n                    Zotero.debug(`Cannot access attachment ${attachmentKey}: ${error.message}`);\n                }\n                \n                // If we still don't have a proper src, use fallback methods\n                if (!finalSrc || finalSrc === `attachments/${attachmentKey}`) {\n                    // Method 1: Check if there are common image extensions in the note content\n                    const commonImageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp', 'tiff', 'ico'];\n                    \n                    // Method 2: Use context clues from surrounding text\n                    let contextExtension = \"\";\n                    const parentText = img.parentElement ? img.parentElement.textContent.toLowerCase() : \"\";\n                    const noteText = noteContent.toLowerCase();\n                    \n                    for (const ext of commonImageExtensions) {\n                        if (parentText.includes(ext) || noteText.includes(`${attachmentKey}.${ext}`)) {\n                            contextExtension = ext;\n                            break;\n                        }\n                    }\n                    \n                    // Method 3: Analyze image dimensions for format hints\n                    let dimensionHint = \"\";\n                    if (width && height) {\n                        const aspectRatio = parseInt(width) / parseInt(height);\n                        // SVG files often have unusual aspect ratios or very large dimensions\n                        if (parseInt(width) > 2000 || parseInt(height) > 2000) {\n                            dimensionHint = \"png\"; // High-res images often PNG\n                        } else if (aspectRatio === 1) {\n                            dimensionHint = \"jpg\"; // Square images often JPG\n                        }\n                    }\n                    \n                    // Method 4: Default to jpg for most compatibility\n                    const defaultExtension = contextExtension || dimensionHint || 'jpg';\n                    fileExtension = defaultExtension;\n                    finalSrc = `attachments/${attachmentKey}.${defaultExtension}`;\n                }\n            }\n            \n            // Only add images with valid src or attachment key\n            if (finalSrc) {\n                const imageObj = {\n                    src: syncPath + \"/\" + finalSrc,\n                    caption: caption,\n                    alt: alt\n                };\n                \n                // Add dimensions if available\n                if (width) imageObj.width = width;\n                if (height) imageObj.height = height;\n                if (attachmentKey) {\n                    imageObj.attachmentKey = attachmentKey;\n                    if (fileExtension) imageObj.fileExtension = fileExtension;\n                }\n                \n                images.push(imageObj);\n            }\n        });\n        \n        return images;\n    };\n\n\tconst formatZoteroDate = (dateTimeString) => {\n\t\t// 입력 문자열을 Date 객체로 파싱합니다.\n\t\t// \"YYYY-MM-DD HH:mm:ss\" 형식은 Date 생성자에서 직접 파싱 가능합니다.\n\t\tconst date = new Date(dateTimeString);\n\n\t\t// 각 날짜/시간 구성 요소를 추출합니다.\n\t\tconst year = date.getFullYear();\n\t\tconst month = (date.getMonth() + 1).toString().padStart(2, '0'); // 월은 0부터 시작하므로 +1\n\t\tconst day = date.getDate().toString().padStart(2, '0');\n\t\tconst hours = date.getHours().toString().padStart(2, '0');\n\t\tconst minutes = date.getMinutes().toString().padStart(2, '0');\n\t\tconst seconds = date.getSeconds().toString().padStart(2, '0');\n\n\t\t// 마이크로초 부분은 요청하신 대로 '0000000'으로 고정합니다.\n\t\tconst microseconds = '0000000'; \n\t\t// attach the timezone stamp\n\t\tconst timezoneOffset = '+00:00'; \n\n\t\t// 모든 구성 요소를 조합하여 최종 문자열을 반환합니다.\n\t\treturn `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${microseconds}${timezoneOffset}`;\n\t};\n\t\n\tlet header = {};\n\tlet noteTags = noteItem.getTags().map((_t) => _t.tag);\n\n\n\theader.parent = noteItem.parentItem ? noteItem.parentItem.getField(\"title\") : \"\";\n\theader.title = noteItem.getField(\"title\") ? noteItem.getField(\"title\") : \"\";\n\theader.content = noteItem.getField(\"content\");\n\n\tconst collections = (\n\t\tawait Zotero.Collections.getCollectionsContainingItems([\n\t\t\t(noteItem.parentItem || noteItem).id,\n\t\t])\n\t).map((c) => c.name);\n\n\tconst extractedImages = extractImages(doc);\n\n\tif (targetTags.some(item => noteTags.includes(item))) {\n\t\theader.type = \"article\";\n\t\theader.flytitle = '';\n\t\theader.headline = header.title ? header.title : noteItem.key;\n\t\theader.rubric = rubric ? rubric : \"기사를 요약하는 문장이 입력하세요. 길이는 10단어 이상 20단어 이하여야 합니다.\";\n\t\theader.slug = slug ? `${slug}` : \"브라우저에 표시하는 기사의 주소입니다. SEO를 고려해 작성하세요.\";\n\t\theader.highlight = {\n\t\t\tlisted: false,\n\t\t\tindex: 1\n\t\t}\n\t\theader.isAccessible = false;\n\t\tconst creationDate = formatZoteroDate(noteItem.dateAdded);\n\t\tconst releaseDate = formatZoteroDate(new Date());\n\t\theader.createdDate = creationDate;\n\t\theader.releaseDate = releaseDate;\n\t\theader.authors = [\"진경수\"];\n\t\tlet getTags = () => { // 이 함수는 매개변수를 받지 않습니다.\n\t\t\tconst setTargetTags = new Set(targetTags); // targetTags는 이 함수의 스코프 밖에서 정의된 것을 참조\n\t\t\treturn noteTags.filter(item => !setTargetTags.has(item));\n\t\t};\n\t\theader.tags = getTags();\n\t\theader.keywords = [\"\"]; \n\n        // Set images array - use extracted images if available, otherwise use default structure\n        if (extractedImages && extractedImages.length > 0) {\n            header.images = extractedImages;\n        } else {\n            header.images = [\n                {\n                    src: extractedImages.length ,\n                    caption: \"\",\n                    alt: \"\"\n                }\n            ];\n        }\n\n\t\theader.revisions = [\n\t\t\t{\n\t\t\t\tauthors: [\"진경수\"],\n\t\t\t\ttimestamp: creationDate,\n\t\t\t\tmessage: \"Zotero 노트에서 초고를 작성함.\"\n\t\t\t}\n\t\t];\n\n\n\t\t\n\t\tdelete header.title;\n\t\tdelete header.parent;\n\t\tdelete header.content;\n\t\t// delete header.collections;\n\t\t// delete header.itemKey;\n\t} else {\n\t\theader.collections = collections;\n\t}\n    let resultString = JSON.stringify(header, null, 2).trim();\n\t// resultString = resultString.replace(/zotero:\\/\\//g, '');\n\t// resultString = resultString;\n\treturn resultString;\n}}$"
-
    name: '[ExportMDFileContent]'
    text: "${{\n\tfunction removeFirstCodeblock(markdownText) {\n\t\tlet result = markdownText;\n\n\t\t// This regex is designed to be more robust:\n\t\t// - It accounts for optional language specifiers (e.g., ```javascript)\n\t\t// - It uses a non-greedy match for the content of the code block.\n\t\t// - It correctly identifies the start and end of a fenced code block on their own lines.\n\t\t// - The 'm' flag is essential for '^' and '$' to match the start/end of lines.\n\t\tconst codeBlockRegex = /^(```|~~~)[\\s\\S]*?\\n\\1(?:\\n|$)/m;\n\t\tresult = result.replace(codeBlockRegex, '');\n\t\treturn result;\n\t}\n\n\tfunction removeFirstBlockquote(markdownText) {\n\t\tlet result = markdownText;\n\n\t\t// Remove the first code block (fenced code block with ``` or ~~~)\n\t\tconst blockquoteRegex = /^>.*(?:\\n>.*)*(?:\\n\\s*)*\\n?/m;\n\t\tresult = result.replace(blockquoteRegex, '');\n\t\tresult = result.trim(); // 시작과 끝의 공백 제거\n\t\tresult = result.replace(/^\\n+/, ''); // 맨 앞의 연속된 빈 줄 제거\n\t\tresult = result.replace(/\\n{3,}/g, '\\n\\n'); // 3줄 이상의 빈 줄을 2줄로 압축\n\t\treturn result;\n\t}\n\n\tfunction removeFirstImage(markdownText) {\n  let result = markdownText;\n\n  // Regular expression to match the first Markdown image: ![alt text](image_url \"optional title\")\n  // This regex handles both inline images and reference-style images (though the latter is less common in this specific pattern)\n  const imageRegex = /!\\[.*?\\]\\(.*?\\)/;\n\n  result = result.replace(imageRegex, ''); // Remove the first occurrence of an image\n  result = result.trim(); // Remove leading and trailing whitespace\n  result = result.replace(/^\\n+/, ''); // Remove any leading blank lines\n  result = result.replace(/\\n{3,}/g, '\\n\\n'); // Compress three or more consecutive blank lines into two\n\n  return result;\n}\n\n\tfunction removeFirstTopLevelHeading(markdownText) {\n    let result = markdownText;\n\n    // This regex targets a line that starts with '#' followed by a space,\n    // and then any characters until the end of the line.\n    // The 'm' flag is crucial for '^' to match the start of each line.\n    const headingRegex = /^#\\s.*(?:\\n|$)/m;\n\n    result = result.replace(headingRegex, '');\n\n    // Clean up extra newlines that might be left behind after removal\n    result = result.replace(/^\\n+/, ''); // Remove leading empty lines\n    result = result.replace(/\\n{3,}/g, '\\n\\n'); // Compress 3+ newlines into 2\n    result = result.trim(); // Trim whitespace from start/end\n\n    return result;\n}\n\n\tfunction polishMarkdown (markdownText) {\n\t\tlet result = markdownText;\n\t\tresult = removeFirstCodeblock(result);\n\t\tresult = removeFirstBlockquote(result);\n\t\tresult = removeFirstTopLevelHeading(result);\n\t\tresult = removeFirstImage(result);\n\t\n\t\treturn \"\\n\" + result;\n\t}\n\n\tconst targetTags = [\"o-m.kr\"];\n\tconst noteTags = noteItem.getTags().map((_t) => _t.tag);\n\n\tlet markdownText;\n\n\tif (targetTags.some(item => noteTags.includes(item))) {\n\t\tmarkdownText = polishMarkdown(mdContent);\n\t} else {\n\t\tmarkdownText = mdContent;\n\t}\n\n\treturn markdownText;\n}}$"
-
    name: '[QuickInsertV3]'
    text: "// @use-markdown\n[${linkText}](${link})"
-
    name: '[ExportLatexFileContent]'
    text: "${{\n  return latexContent;\n}}$"
