-
    name: '[QuickInsertV2]'
    text: "<p>\n  <a href=\"${link}\">\n    ${linkText}\n  </a>\n</p>"
-
    name: '[QuickBackLinkV2]'
    text: "<p>\n  Referred in\n  <a href=\"${link}\">\n    ${linkText}\n  </a>\n</p>"
-
    name: '[QuickImportV2]'
    text: "<blockquote>\n${{\n  return await Zotero.BetterNotes.api.convert.link2html(link, {noteItem, dryRun: _env.dryRun});\n}}$\n</blockquote>"
-
    name: '[QuickNoteV5]'
    text: "${{\n  let res = \"\";\n  if (annotationItem.annotationComment) {\n    res += await Zotero.BetterNotes.api.convert.md2html(\n      annotationItem.annotationComment\n    );\n  }\n  res += await Zotero.BetterNotes.api.convert.annotations2html([annotationItem], {noteItem, ignoreComment: true});\n  return res;\n}}$"
-
    name: '[ExportMDFileNameV2]'
    text: "${{\r\n\tconst noteTitle = (noteItem.getNoteTitle ? noteItem.getNoteTitle().replace(/[/\\\\?%*:|\"<> ]/g, \"-\") + \"-\" : \"\");\r\n\tconst noteKey = noteItem.key;\r\n\tconst fileExtension = [\"mdx\", \"md\"];\r\n\tlet fileName = \"\";\r\n\r\n\tconst targetTags = [\"o-m.kr\"];\r\n\tconst noteTags = noteItem.getTags().map((_t) => _t.tag);\r\n\t\r\n\tif (targetTags.some(item => noteTags.includes(item))) {\r\n\t\tfileName = `${noteTitle}-${noteKey}.${fileExtension[0]}`;\r\n\t} else {\r\n\t\tfileName = `${noteTitle}-${noteKey}.${fileExtension[1]}`;\r\n\t}\r\n\treturn fileName;\r\n}}$"
-
    name: '[ExportMDFileHeaderV2]'
    text: "${{\n\tconst targetTags = [\"o-m.kr\"];\n\n\tlet noteContent = noteItem.getNote(); // This retrieves the HTML content of the note as a string\n\n\t// Create a DOMParser to parse the HTML string\n\tlet parser = new DOMParser();\n\tconst doc = parser.parseFromString(noteContent, 'text/html');\n\n\t// Find the first blockquote element\n\tlet firstBlockquote = doc.querySelector('blockquote');\n\tlet rubric = \"\";\n\n\tif (firstBlockquote) {\n\t\tlet blockquoteText = firstBlockquote.textContent.trim();\n\t\trubric = blockquoteText;\n\t} else {\n\t\t// Zotero.debug(\"No blockquote found in the note.\");\n\t\trubric = false;\n\t}\n\n\tlet firstPre = doc.querySelector('pre');\n\tlet slug = \"\";\n\tif (firstPre) {\n\t\tlet slugText = firstPre.textContent.trim();\n\t\tslug = slugText;\n\t} else {\n\t\tslug = false;\n\t}\n\n\tconst formatZoteroDate = (dateTimeString) => {\n\t\t// 입력 문자열을 Date 객체로 파싱합니다.\n\t\t// \"YYYY-MM-DD HH:mm:ss\" 형식은 Date 생성자에서 직접 파싱 가능합니다.\n\t\tconst date = new Date(dateTimeString);\n\n\t\t// 각 날짜/시간 구성 요소를 추출합니다.\n\t\tconst year = date.getFullYear();\n\t\tconst month = (date.getMonth() + 1).toString().padStart(2, '0'); // 월은 0부터 시작하므로 +1\n\t\tconst day = date.getDate().toString().padStart(2, '0');\n\t\tconst hours = date.getHours().toString().padStart(2, '0');\n\t\tconst minutes = date.getMinutes().toString().padStart(2, '0');\n\t\tconst seconds = date.getSeconds().toString().padStart(2, '0');\n\n\t\t// 마이크로초 부분은 요청하신 대로 '0000000'으로 고정합니다.\n\t\tconst microseconds = '0000000'; \n\t\t// attach the timezone stamp\n\t\tconst timezoneOffset = '+00:00'; \n\n\t\t// 모든 구성 요소를 조합하여 최종 문자열을 반환합니다.\n\t\treturn `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${microseconds}${timezoneOffset}`;\n\t};\n\t\n\tlet header = {};\n\tlet noteTags = noteItem.getTags().map((_t) => _t.tag);\n\n\n\theader.parent = noteItem.parentItem ? noteItem.parentItem.getField(\"title\") : \"\";\n\theader.title = noteItem.getField(\"title\") ? noteItem.getField(\"title\") : \"\";\n\theader.content = noteItem.getField(\"content\");\n\n\tconst collections = (\n\t\tawait Zotero.Collections.getCollectionsContainingItems([\n\t\t\t(noteItem.parentItem || noteItem).id,\n\t\t])\n\t).map((c) => c.name);\n\n\tif (targetTags.some(item => noteTags.includes(item))) {\n\t\theader.type = \"article\";\n\t\theader.flytitle = '';\n\t\theader.headline = header.title;\n\t\theader.rubric = rubric ? rubric : \"기사를 요약하는 문장이 입력하세요. 길이는 10단어 이상 20단어 이하여야 합니다.\";\n\t\theader.slug = slug ? `${slug}` : \"브라우저에 표시하는 기사의 주소입니다. SEO를 고려해 작성하세요.\";\n\t\theader.highlight = {\n\t\t\tlisted: false,\n\t\t\tindex: 1\n\t\t}\n\t\theader.isAccessible = false;\n\t\tconst creationDate = formatZoteroDate(noteItem.dateAdded);\n\t\tconst releaseDate = formatZoteroDate(new Date());\n\t\theader.createdDate = creationDate;\n\t\theader.releaseDate = releaseDate;\n\t\theader.authors = [\"진경수\"];\n\t\tlet getTags = () => { // 이 함수는 매개변수를 받지 않습니다.\n\t\t\tconst setTargetTags = new Set(targetTags); // targetTags는 이 함수의 스코프 밖에서 정의된 것을 참조\n\t\t\treturn noteTags.filter(item => !setTargetTags.has(item));\n\t\t};\n\t\theader.tags = getTags();\n\t\theader.keywords = [\"\"]; \n\t\theader.images = [\n\t\t\t{\n\t\t\t\tsrc: \"\",\n\t\t\t\tcaption: \"\",\n\t\t\t\talt: \"\"\n\t\t\t}\n\t\t];\n\t\theader.revisions = [\n\t\t\t{\n\t\t\t\tauthors: [\"진경수\"],\n\t\t\t\ttimestamp: creationDate,\n\t\t\t\tmessage: \"Zotero 노트에서 초고를 작성함.\"\n\t\t\t}\n\t\t];\n\n\t\tdelete header.title;\n\t\tdelete header.parent;\n\t\tdelete header.content;\n\t\t// delete header.collections;\n\t\t// delete header.itemKey;\n\t} else {\n\t\theader.collections = collections;\n\t}\n\tlet resultString = JSON.stringify(header).trim();\n\t// resultString = resultString;\n\treturn resultString;\n}}$"
-
    name: '[ExportMDFileContent]'
    text: "${{\n\tfunction removeFirstCodeblock(markdownText) {\n\t\tlet result = markdownText;\n\n\t\t// This regex is designed to be more robust:\n\t\t// - It accounts for optional language specifiers (e.g., ```javascript)\n\t\t// - It uses a non-greedy match for the content of the code block.\n\t\t// - It correctly identifies the start and end of a fenced code block on their own lines.\n\t\t// - The 'm' flag is essential for '^' and '$' to match the start/end of lines.\n\t\tconst codeBlockRegex = /^(```|~~~)[\\s\\S]*?\\n\\1(?:\\n|$)/m;\n\t\tresult = result.replace(codeBlockRegex, '');\n\t\treturn result;\n\t}\n\n\tfunction removeFirstBlockquote(markdownText) {\n\t\tlet result = markdownText;\n\n\t\t// Remove the first code block (fenced code block with ``` or ~~~)\n\t\tconst blockquoteRegex = /^>.*(?:\\n>.*)*(?:\\n\\s*)*\\n?/m;\n\t\tresult = result.replace(blockquoteRegex, '');\n\t\tresult = result.trim(); // 시작과 끝의 공백 제거\n\t\tresult = result.replace(/^\\n+/, ''); // 맨 앞의 연속된 빈 줄 제거\n\t\tresult = result.replace(/\\n{3,}/g, '\\n\\n'); // 3줄 이상의 빈 줄을 2줄로 압축\n\t\treturn result;\n\t}\n\n\tfunction removeFirstTopLevelHeading(markdownText) {\n    let result = markdownText;\n\n    // This regex targets a line that starts with '#' followed by a space,\n    // and then any characters until the end of the line.\n    // The 'm' flag is crucial for '^' to match the start of each line.\n    const headingRegex = /^#\\s.*(?:\\n|$)/m;\n\n    result = result.replace(headingRegex, '');\n\n    // Clean up extra newlines that might be left behind after removal\n    result = result.replace(/^\\n+/, ''); // Remove leading empty lines\n    result = result.replace(/\\n{3,}/g, '\\n\\n'); // Compress 3+ newlines into 2\n    result = result.trim(); // Trim whitespace from start/end\n\n    return result;\n}\n\n\tfunction polishMarkdown (markdownText) {\n\t\tlet result = markdownText;\n\t\tresult = removeFirstCodeblock(result);\n\t\tresult = removeFirstBlockquote(result);\n\t\tresult = removeFirstTopLevelHeading(result);\n\t\n\t\treturn \"\\n\" + result;\n\t}\n\n\tconst targetTags = [\"o-m.kr\"];\n\tconst noteTags = noteItem.getTags().map((_t) => _t.tag);\n\n\tlet markdownText;\n\n\tif (targetTags.some(item => noteTags.includes(item))) {\n\t\tmarkdownText = polishMarkdown(mdContent);\n\t} else {\n\t\tmarkdownText = mdContent;\n\t}\n\n\treturn markdownText;\n}}$"
-
    name: '[QuickInsertV3]'
    text: "// @use-markdown\n[${linkText}](${link})"
-
    name: '[ExportLatexFileContent]'
    text: "${{\n  return latexContent;\n}}$"
